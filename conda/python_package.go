package conda

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime/trace"
	"strconv"
	"strings"
	"time"

	"github.com/10XGenomics/rules_conda/buildutil"
	"github.com/bazelbuild/buildtools/build"
)

func getImportPaths(pythonExe string) (version string, paths []string, err error) {
	ctx, cancel := context.WithTimeout(context.TODO(), time.Minute)
	defer cancel()
	r := trace.StartRegion(ctx, "python paths")
	defer r.End()
	absRoot, err := filepath.Abs(pythonExe)
	if err != nil {
		panic(err)
	}
	absRoot = path.Dir(path.Dir(absRoot)) + string([]rune{os.PathSeparator})
	cmd := exec.CommandContext(ctx,
		pythonExe,
		"-c", `
import json
import sys

json.dump({
	"path": sys.path,
	"version": sys.version_info[:3]
}, sys.stdout)
`)
	cmd.Stderr = os.Stderr
	var pathList struct {
		Paths   []string `json:"path"`
		Version []int    `json:"version"`
	}
	if o, err := cmd.Output(); err != nil {
		return "", nil, err
	} else if err := json.Unmarshal(o, &pathList); err != nil {
		return "", nil, err
	}
	paths = make([]string, 0, len(pathList.Paths))
	for _, p := range pathList.Paths {
		if sp := strings.TrimPrefix(p, absRoot); !path.IsAbs(sp) &&
			sp != "" && path.Ext(sp) != ".zip" {
			paths = append(paths, sp)
		}
	}
	var ver strings.Builder
	ver.Grow(8)
	for i, v := range pathList.Version {
		if i > 0 {
			if err := ver.WriteByte('.'); err != nil {
				panic(err)
			}
		}
		if _, err := ver.WriteString(strconv.Itoa(v)); err != nil {
			panic(err)
		}
	}
	return ver.String(), paths, nil
}

func generateVarsFile(dest, condaRepo, pyVersion, longestPath string, pyImports []string) error {
	fmt.Fprintln(os.Stderr, "Generating vars.bzl files...")
	importPaths := make([]build.Expr, len(pyImports))
	condaRepo = strings.TrimPrefix(condaRepo, "@")
	for i, p := range pyImports {
		importPaths[i] = buildutil.StrExpr(path.Join(condaRepo, p))
	}
	importPathsExpr := buildutil.ListExpr(importPaths...)
	importPathsExpr.ForceMultiLine = true
	f := build.File{
		Path: "vars.bzl",
		Type: build.TypeDefault,
		Comments: build.Comments{
			Before: []build.Comment{
				{
					Token: "# Code generated by generate_conda_repo. DO NOT EDIT.\n\n",
				},
			},
		},
		Stmt: []build.Expr{
			&build.StringExpr{
				Value:       "Variables to be imported by other packages.",
				TripleQuote: true,
			},
			&build.AssignExpr{
				Comments: build.Comments{
					Before: []build.Comment{
						{
							Token: "# The version (x.y.z) of python.\n",
						},
					},
				},
				LHS: &build.Ident{Name: "PYTHON_VERSION"},
				Op:  "=",
				RHS: buildutil.StrExpr(pyVersion),
			},
			&build.AssignExpr{
				Comments: build.Comments{
					Before: []build.Comment{
						{
							Token: "# The version (x.y.z) of python.\n",
						},
					},
				},
				LHS: &build.Ident{Name: "PYTHON_PREFIX"},
				Op:  "=",
				RHS: buildutil.StrExpr(longestPath),
			},
			&build.AssignExpr{
				Comments: build.Comments{
					Before: []build.Comment{
						{
							Token: "# The path, relative to the execution " +
								"root, of the conda bin directory.\n",
						},
					},
				},
				LHS: &build.Ident{Name: "BIN"},
				Op:  "=",
				RHS: buildutil.StrExpr(path.Join("external", condaRepo, "bin")),
			},
			&build.AssignExpr{
				Comments: build.Comments{
					Before: []build.Comment{
						{
							Token: "# The path, relative to the execution " +
								"root, of the conda include directory.\n",
						},
					},
				},
				LHS: &build.Ident{Name: "INCLUDE"},
				Op:  "=",
				RHS: buildutil.StrExpr(path.Join("external", condaRepo, "include")),
			},
			&build.AssignExpr{
				Comments: build.Comments{
					Before: []build.Comment{
						{
							Token: "# The path, relative to the execution " +
								"root, of the conda lib directory.\n",
						},
					},
				},
				LHS: &build.Ident{Name: "LIB"},
				Op:  "=",
				RHS: buildutil.StrExpr(path.Join("external", condaRepo, "lib")),
			},
			&build.AssignExpr{
				Comments: build.Comments{
					Before: []build.Comment{
						{
							Token: "# Default python import paths.",
						},
					},
				},
				LHS: &build.Ident{Name: "PY_IMPORT_PATHS"},
				Op:  "=",
				RHS: importPathsExpr,
			},
		},
	}
	return os.WriteFile(path.Join(dest, "vars.bzl"),
		build.Format(&f), 0666)
}

func (pkg *Package) writePythonVars(condaRepo string) error {
	version, importPaths, err := getImportPaths(path.Join(pkg.Dir, "bin", "python"))
	if err != nil {
		return err
	}
	var longest string
	if len(importPaths) > 0 {
		longest = importPaths[0]
		for _, p := range importPaths[1:] {
			if len(p) > len(longest) {
				longest = p
			}
		}
	}
	return generateVarsFile(pkg.Dir, condaRepo,
		version, path.Dir(longest), importPaths)
}
